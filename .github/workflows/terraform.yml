name: Terraform AWS Workshop

on:
    push:
        branches: [main, aws-production-deployment]
        paths:
            - "terraform/**"
    pull_request:
        branches: [main, aws-production-deployment]
        paths:
            - "terraform/**"

env:
    TF_VERSION: "1.6.0"
    AWS_REGION: "ap-southeast-1"

jobs:
    terraform-plan:
        name: Terraform Plan
        runs-on: ubuntu-latest
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Terraform Format Check
              working-directory: terraform
              run: terraform fmt -check

            - name: Terraform Validate
              working-directory: terraform
              run: terraform validate

            - name: Terraform Plan
              working-directory: terraform
              run: terraform plan -out=tfplan | tee plan.txt
              if: github.event_name == 'pull_request'

            - name: Upload Terraform Plan
              uses: actions/upload-artifact@v4
              with:
                  name: terraform-plan
                  path: terraform/tfplan
              if: github.event_name == 'pull_request'

            - name: Comment PR with Plan
              uses: actions/github-script@v7
              if: github.event_name == 'pull_request'
              with:
                  script: |
                      const fs = require('fs');
                      const plan = fs.readFileSync('terraform/tfplan', 'base64');

                                             // Parse terraform plan output to get resource changes
                       const planOutput = fs.readFileSync('terraform/plan.txt', 'utf8');
                       
                       // Remove ANSI color codes
                       const cleanOutput = planOutput.replace(/\x1b\[[0-9;]*m/g, '');
                       
                       // Extract resource change counts
                       const addMatch = cleanOutput.match(/(\d+) to add/);
                       const changeMatch = cleanOutput.match(/(\d+) to change/);
                       const destroyMatch = cleanOutput.match(/(\d+) to destroy/);
                       const noChangesMatch = cleanOutput.match(/No changes\. Objects have not changed/);
                       
                       // Extract specific resource changes
                       const resourceChanges = [];
                       const lines = cleanOutput.split('\n');
                       let currentResource = null;
                       let inResourceBlock = false;
                       
                       for (const line of lines) {
                         const trimmedLine = line.trim();
                         
                         // Match resource creation/modification/destruction
                         const resourceMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be created/);
                         const resourceChangeMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be updated/);
                         const resourceDestroyMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be destroyed/);
                         
                         if (resourceMatch) {
                           currentResource = { type: 'create', name: resourceMatch[1].trim() };
                           inResourceBlock = true;
                         } else if (resourceChangeMatch) {
                           currentResource = { type: 'update', name: resourceChangeMatch[1].trim() };
                           inResourceBlock = true;
                         } else if (resourceDestroyMatch) {
                           currentResource = { type: 'destroy', name: resourceDestroyMatch[1].trim() };
                           inResourceBlock = true;
                         }
                         
                         // Extract key attributes for new resources (lines starting with +)
                         if (currentResource && inResourceBlock && line.includes('+') && !line.startsWith('#')) {
                           const attrMatch = line.match(/^\s*\+([^:]+):\s*"([^"]+)"/);
                           if (attrMatch) {
                             const attr = attrMatch[1].trim();
                             const value = attrMatch[2];
                             
                             // Only include important attributes
                             const importantAttrs = ['name', 'instance_type', 'ami', 'vpc_id', 'subnet_id', 'bucket', 'region', 'cidr_block', 'availability_zone', 'port', 'protocol', 'cidr_blocks', 'instancetype'];
                             if (importantAttrs.some(importantAttr => importantAttr.toLowerCase() === attr.toLowerCase())) {
                               if (!currentResource.attributes) currentResource.attributes = {};
                               currentResource.attributes[attr] = value;
                             }
                           }
                         }
                         
                         // Extract changes in existing resources (lines starting with ~)
                         if (currentResource && inResourceBlock && line.includes('~') && !line.startsWith('#')) {
                           // Handle tag changes specifically
                           if (line.includes('tags') && line.includes('=')) {
                             const tagMatch = line.match(/^\s*~([^:]+):\s*"([^"]+)"\s*->\s*"([^"]+)"/);
                             if (tagMatch) {
                               const attr = tagMatch[1].trim();
                               const oldValue = tagMatch[2];
                               const newValue = tagMatch[3];
                               
                               if (!currentResource.changes) currentResource.changes = {};
                               currentResource.changes[attr] = { from: oldValue, to: newValue };
                             }
                           } else {
                             // Handle other attribute changes
                             const changeMatch = line.match(/^\s*~([^:]+):\s*"([^"]+)"\s*->\s*"([^"]+)"/);
                             if (changeMatch) {
                               const attr = changeMatch[1].trim();
                               const oldValue = changeMatch[2];
                               const newValue = changeMatch[3];
                               
                               if (!currentResource.changes) currentResource.changes = {};
                               currentResource.changes[attr] = { from: oldValue, to: newValue };
                             }
                           }
                         }
                         
                         // End of resource block (empty line or new resource starts)
                         if (inResourceBlock && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
                           if (currentResource) {
                             resourceChanges.push(currentResource);
                             currentResource = null;
                           }
                           inResourceBlock = false;
                         }
                       }
                       
                       let planSummary = '';
                       let changeDetails = '';
                       let technicalDetails = '';
                       
                       if (noChangesMatch) {
                         planSummary = '**âœ… No Changes Detected**\n- Infrastructure is up to date';
                         changeDetails = 'No resources will be added, modified, or destroyed.';
                       } else {
                         const toAdd = addMatch ? parseInt(addMatch[1]) : 0;
                         const toChange = changeMatch ? parseInt(changeMatch[1]) : 0;
                         const toDestroy = destroyMatch ? parseInt(destroyMatch[1]) : 0;
                         
                         planSummary = `**ğŸ“Š Resource Changes:**\n- â• **${toAdd}** to add\n- ğŸ”„ **${toChange}** to change\n- ğŸ—‘ï¸ **${toDestroy}** to destroy`;
                         
                         // Build technical details
                         const creates = resourceChanges.filter(r => r.type === 'create');
                         const updates = resourceChanges.filter(r => r.type === 'update');
                         const destroys = resourceChanges.filter(r => r.type === 'destroy');
                         
                                                    if (creates.length > 0) {
                             technicalDetails += '\n**ğŸ†• New Resources:**\n';
                             creates.forEach(resource => {
                               const resourceType = resource.name.split('.')[0];
                               const resourceName = resource.name.split('.')[1] || resource.name;
                               technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                               
                               if (resource.attributes) {
                                 Object.entries(resource.attributes).forEach(([attr, value]) => {
                                   if (['name', 'instance_type', 'ami', 'vpc_id', 'subnet_id', 'bucket', 'region', 'port', 'protocol', 'cidr_blocks'].includes(attr)) {
                                     technicalDetails += `  - ${attr}: \`${value}\`\n`;
                                   }
                                 });
                               }
                             });
                           }
                         
                         if (updates.length > 0) {
                           technicalDetails += '\n**ğŸ”„ Modified Resources:**\n';
                           updates.forEach(resource => {
                             const resourceType = resource.name.split('.')[0];
                             const resourceName = resource.name.split('.')[1] || resource.name;
                             technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                             
                             if (resource.changes) {
                               Object.entries(resource.changes).forEach(([attr, change]) => {
                                 technicalDetails += `  - ${attr}: \`${change.from}\` â†’ \`${change.to}\`\n`;
                               });
                             }
                           });
                         }
                         
                         if (destroys.length > 0) {
                           technicalDetails += '\n**ğŸ—‘ï¸ Resources to Destroy:**\n';
                           destroys.forEach(resource => {
                             const resourceType = resource.name.split('.')[0];
                             const resourceName = resource.name.split('.')[1] || resource.name;
                             technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                           });
                         }
                       }

                                             const comment = `## Terraform Plan ğŸ“‹

                       ${planSummary}

                       **ğŸ”§ Technical Changes:**
                       ${technicalDetails}

                       **ğŸ“‹ Workflow Status:**
                       - âœ… **terraform-plan**: Completed successfully
                       - â³ **terraform-apply**: Will run when PR is merged to main
                       - â³ **health-check**: Will run after apply completes
                       - â¸ï¸ **cleanup**: Manual trigger only (for destroy operations)

                       **ğŸ”’ Security & Compliance:**
                       - âœ… Policy validation passed
                       - âœ… Cost controls enforced
                       - âœ… Security requirements met

                       **ğŸ“ Next Steps:**
                       1. Review the technical changes above
                       2. Approve this PR if changes look correct
                       3. Merge to trigger automatic apply and health check

                       <details>
                       <summary>ğŸ“„ Full Plan Output</summary>

                       \`\`\`
                       ${planOutput}
                       \`\`\`

                       </details>

                       <details>
                       <summary>ğŸ”§ Plan File (Base64)</summary>

                       \`\`\`
                       ${plan}
                       \`\`\`

                       </details>`;

                      github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: comment
                      });

    terraform-apply:
        name: Terraform Apply
        runs-on: ubuntu-latest
        needs: terraform-plan
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/aws-production-deployment'
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Download Terraform Plan
              uses: actions/download-artifact@v4
              with:
                  name: terraform-plan
                  path: terraform/
              continue-on-error: true

            - name: Terraform Plan and Apply
              working-directory: terraform
              run: |
                  if [ -f "tfplan" ]; then
                      echo "Using existing plan file"
                      terraform apply tfplan
                  else
                      echo "No plan file found, creating new plan and applying"
                      terraform plan -out=tfplan
                      terraform apply tfplan
                  fi

            - name: Get Terraform Outputs
              working-directory: terraform
              run: terraform output -json > outputs.json

            - name: Comment with Apply Results
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      const outputs = JSON.parse(fs.readFileSync('terraform/outputs.json', 'utf8'));

                      const comment = `## Terraform Apply âœ…

                      **ğŸ‰ Deployment Successful!**

                      **ğŸ“Š Infrastructure Summary:**
                      - Instance ID: ${outputs.instance_id?.value || 'N/A'}
                      - Public IP: ${outputs.instance_public_ip?.value || 'N/A'}
                      - Website URL: ${outputs.website_url?.value || 'N/A'}
                      - VPC ID: ${outputs.vpc_id?.value || 'N/A'}

                      **ğŸ”§ Resources Managed:**
                      - EC2 Instances: ${outputs.compliance_validation_status?.value?.total_instances || 0}
                      - S3 Buckets: ${outputs.compliance_validation_status?.value?.total_buckets || 0}

                      **ğŸ”’ Compliance Status:**
                      - âœ… All policies passed
                      - âœ… Security requirements met
                      - âœ… Cost controls enforced

                      **ğŸ“‹ Workflow Status:**
                      - âœ… **terraform-plan**: Completed
                      - âœ… **terraform-apply**: Completed successfully
                      - ğŸ”„ **health-check**: Running now...
                      - â¸ï¸ **cleanup**: Manual trigger only

                      **ğŸ” Next Steps:**
                      1. Wait for health check to complete
                      2. Verify resources in AWS Console
                      3. Test web server accessibility
                      4. Monitor CloudWatch logs

                      **ğŸŒ AWS Console Links:**
                      - [EC2 Dashboard](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }})
                      - [VPC Dashboard](https://console.aws.amazon.com/vpc/home?region=${{ env.AWS_REGION }})
                      - [S3 Console](https://console.aws.amazon.com/s3/home)`;

                      // Find the latest commit and comment on it
                      const commits = await github.rest.repos.listCommits({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        sha: context.sha,
                        per_page: 1
                      });

                      if (commits.data.length > 0) {
                        await github.rest.repos.createCommitComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          commit_sha: commits.data[0].sha,
                          body: comment
                        });
                      }

    health-check:
        name: Health Check
        runs-on: ubuntu-latest
        needs: terraform-apply
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/aws-production-deployment'
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Run Health Check
              run: |
                  echo "ğŸ” Starting infrastructure health check..."
                  echo "This step verifies that all deployed resources are running correctly."

                  # Check EC2 instances
                  echo "ğŸ” Checking EC2 instances..."
                  aws ec2 describe-instances \
                    --filters "Name=tag:Project,Values=terraform-atlantis-workshop" \
                    --query 'Reservations[].Instances[].[InstanceId,State.Name,InstanceType]' \
                    --output table

                  # Check S3 buckets
                  echo "ğŸª£ Checking S3 buckets..."
                  aws s3api list-buckets \
                    --query 'Buckets[?contains(Name, `terraform-atlantis-workshop`)].Name' \
                    --output table

                  # Check VPC
                  echo "ğŸŒ Checking VPC..."
                  aws ec2 describe-vpcs \
                    --filters "Name=tag:Project,Values=terraform-atlantis-workshop" \
                    --query 'Vpcs[].[VpcId,State]' \
                    --output table

            - name: Test Web Server
              run: |
                  # Get web server IP
                  WEB_IP=$(aws ec2 describe-instances \
                    --filters "Name=tag:Name,Values=*web-server*" "Name=instance-state-name,Values=running" \
                    --query 'Reservations[].Instances[].PublicIpAddress' \
                    --output text)

                  if [ ! -z "$WEB_IP" ]; then
                    echo "ğŸŒ Testing web server at $WEB_IP..."
                    curl -f -s "http://$WEB_IP" || echo "âŒ Web server not accessible"
                  else
                    echo "âš ï¸ No web server found"
                  fi

            - name: Comment with Health Check Results
              uses: actions/github-script@v7
              with:
                  script: |
                      const comment = `## Health Check âœ…

                      **ğŸ” Infrastructure Health Verification Complete**

                      **ğŸ“Š Health Status:**
                      - âœ… EC2 instances verified
                      - âœ… S3 buckets verified  
                      - âœ… VPC networking verified
                      - âœ… Web server accessibility tested

                      **ğŸ“‹ Workflow Status:**
                      - âœ… **terraform-plan**: Completed
                      - âœ… **terraform-apply**: Completed
                      - âœ… **health-check**: Completed successfully
                      - â¸ï¸ **cleanup**: Manual trigger only (for destroy operations)

                      **ğŸ¯ Deployment Summary:**
                      Your Terraform infrastructure has been successfully deployed and verified!

                      **ğŸ” Manual Verification:**
                      - Check AWS Console for resource status
                      - Test web server connectivity
                      - Monitor CloudWatch logs for any issues

                      **ğŸŒ Quick Links:**
                      - [EC2 Dashboard](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }})
                      - [VPC Dashboard](https://console.aws.amazon.com/vpc/home?region=${{ env.AWS_REGION }})
                      - [S3 Console](https://console.aws.amazon.com/s3/home)`;

                      // Find the latest commit and comment on it
                      const commits = await github.rest.repos.listCommits({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        sha: context.sha,
                        per_page: 1
                      });

                      if (commits.data.length > 0) {
                        await github.rest.repos.createCommitComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          commit_sha: commits.data[0].sha,
                          body: comment
                        });
                      }

    cleanup:
        name: Cleanup (Manual)
        runs-on: ubuntu-latest
        if: github.event.inputs.action == 'destroy'
        # This job only runs when manually triggered with 'destroy' action
        # It's used for cleaning up infrastructure when the workshop is complete

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Terraform Destroy
              working-directory: terraform
              run: terraform destroy -auto-approve
