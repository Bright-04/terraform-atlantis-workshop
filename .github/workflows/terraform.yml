name: Terraform AWS Workshop

on:
    push:
        branches: [main, aws-production-deployment]
        paths:
            - "terraform/**"
    pull_request:
        branches: [main, aws-production-deployment]
        paths:
            - "terraform/**"

env:
    TF_VERSION: "1.6.0"
    AWS_REGION: "ap-southeast-1"

jobs:
    terraform-plan:
        name: Terraform Plan
        runs-on: ubuntu-latest
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Terraform Format Check
              working-directory: terraform
              run: |
                  echo "üîç Checking Terraform formatting..."
                  if terraform fmt -check; then
                      echo "‚úÖ Terraform formatting is correct"
                  else
                      echo "‚ùå Terraform formatting check failed"
                      echo "Please run 'terraform fmt' to fix formatting issues"
                      echo "Files that need formatting:"
                      terraform fmt -check -recursive || true
                      exit 1
                  fi

            - name: Terraform Validate
              working-directory: terraform
              run: |
                  echo "üîç Validating Terraform configuration..."
                  if terraform validate; then
                      echo "‚úÖ Terraform configuration is valid"
                  else
                      echo "‚ùå Terraform validation failed"
                      echo "Please check your Terraform configuration for syntax errors"
                      exit 1
                  fi

            - name: Terraform Plan
              working-directory: terraform
              run: terraform plan -out=tfplan | tee plan.txt
              if: github.event_name == 'pull_request'

            - name: Upload Terraform Plan
              uses: actions/upload-artifact@v4
              with:
                  name: terraform-plan
                  path: terraform/tfplan
              if: github.event_name == 'pull_request'

            - name: Comment PR with Plan
              uses: actions/github-script@v7
              if: github.event_name == 'pull_request'
              with:
                  script: |
                      const fs = require('fs');
                      const plan = fs.readFileSync('terraform/tfplan', 'base64');

                                             // Parse terraform plan output to get resource changes
                       const planOutput = fs.readFileSync('terraform/plan.txt', 'utf8');
                       
                       // Remove ANSI color codes
                       const cleanOutput = planOutput.replace(/\x1b\[[0-9;]*m/g, '');
                       
                       // Extract resource change counts
                       const addMatch = cleanOutput.match(/(\d+) to add/);
                       const changeMatch = cleanOutput.match(/(\d+) to change/);
                       const destroyMatch = cleanOutput.match(/(\d+) to destroy/);
                       const noChangesMatch = cleanOutput.match(/No changes\. Objects have not changed/);
                       
                       // Extract specific resource changes
                       const resourceChanges = [];
                       const lines = cleanOutput.split('\n');
                       let currentResource = null;
                       let inResourceBlock = false;
                       
                       for (const line of lines) {
                         const trimmedLine = line.trim();
                         
                         // Match resource creation/modification/destruction
                         const resourceMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be created/);
                         const resourceChangeMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be updated/);
                         const resourceDestroyMatch = trimmedLine.match(/^#\s*([^#]+)\s*will be destroyed/);
                         
                         if (resourceMatch) {
                           currentResource = { type: 'create', name: resourceMatch[1].trim() };
                           inResourceBlock = true;
                         } else if (resourceChangeMatch) {
                           currentResource = { type: 'update', name: resourceChangeMatch[1].trim() };
                           inResourceBlock = true;
                         } else if (resourceDestroyMatch) {
                           currentResource = { type: 'destroy', name: resourceDestroyMatch[1].trim() };
                           inResourceBlock = true;
                         }
                         
                         // Extract key attributes for new resources (lines starting with +)
                         if (currentResource && inResourceBlock && line.includes('+') && !line.startsWith('#')) {
                           const attrMatch = line.match(/^\s*\+([^:]+):\s*"([^"]+)"/);
                           if (attrMatch) {
                             const attr = attrMatch[1].trim();
                             const value = attrMatch[2];
                             
                             // Only include important attributes
                             const importantAttrs = ['name', 'instance_type', 'ami', 'vpc_id', 'subnet_id', 'bucket', 'region', 'cidr_block', 'availability_zone', 'port', 'protocol', 'cidr_blocks', 'instancetype'];
                             if (importantAttrs.some(importantAttr => importantAttr.toLowerCase() === attr.toLowerCase())) {
                               if (!currentResource.attributes) currentResource.attributes = {};
                               currentResource.attributes[attr] = value;
                             }
                           }
                         }
                         
                         // Extract changes in existing resources (lines starting with ~)
                         if (currentResource && inResourceBlock && line.includes('~') && !line.startsWith('#')) {
                           // Handle tag changes specifically
                           if (line.includes('tags') && line.includes('=')) {
                             const tagMatch = line.match(/^\s*~([^:]+):\s*"([^"]+)"\s*->\s*"([^"]+)"/);
                             if (tagMatch) {
                               const attr = tagMatch[1].trim();
                               const oldValue = tagMatch[2];
                               const newValue = tagMatch[3];
                               
                               if (!currentResource.changes) currentResource.changes = {};
                               currentResource.changes[attr] = { from: oldValue, to: newValue };
                             }
                           } else {
                             // Handle other attribute changes
                             const changeMatch = line.match(/^\s*~([^:]+):\s*"([^"]+)"\s*->\s*"([^"]+)"/);
                             if (changeMatch) {
                               const attr = changeMatch[1].trim();
                               const oldValue = changeMatch[2];
                               const newValue = changeMatch[3];
                               
                               if (!currentResource.changes) currentResource.changes = {};
                               currentResource.changes[attr] = { from: oldValue, to: newValue };
                             }
                           }
                         }
                         
                         // End of resource block (empty line or new resource starts)
                         if (inResourceBlock && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
                           if (currentResource) {
                             resourceChanges.push(currentResource);
                             currentResource = null;
                           }
                           inResourceBlock = false;
                         }
                       }
                       
                       let planSummary = '';
                       let changeDetails = '';
                       let technicalDetails = '';
                       
                       if (noChangesMatch) {
                         planSummary = '**‚úÖ No Changes Detected**\n- Infrastructure is up to date';
                         changeDetails = 'No resources will be added, modified, or destroyed.';
                       } else {
                         const toAdd = addMatch ? parseInt(addMatch[1]) : 0;
                         const toChange = changeMatch ? parseInt(changeMatch[1]) : 0;
                         const toDestroy = destroyMatch ? parseInt(destroyMatch[1]) : 0;
                         
                         planSummary = `**üìä Resource Changes:**\n- ‚ûï **${toAdd}** to add\n- üîÑ **${toChange}** to change\n- üóëÔ∏è **${toDestroy}** to destroy`;
                         
                         // Build technical details
                         const creates = resourceChanges.filter(r => r.type === 'create');
                         const updates = resourceChanges.filter(r => r.type === 'update');
                         const destroys = resourceChanges.filter(r => r.type === 'destroy');
                         
                                                    if (creates.length > 0) {
                             technicalDetails += '\n**üÜï New Resources:**\n';
                             creates.forEach(resource => {
                               const resourceType = resource.name.split('.')[0];
                               const resourceName = resource.name.split('.')[1] || resource.name;
                               technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                               
                               if (resource.attributes) {
                                 Object.entries(resource.attributes).forEach(([attr, value]) => {
                                   if (['name', 'instance_type', 'ami', 'vpc_id', 'subnet_id', 'bucket', 'region', 'port', 'protocol', 'cidr_blocks'].includes(attr)) {
                                     technicalDetails += `  - ${attr}: \`${value}\`\n`;
                                   }
                                 });
                               }
                             });
                           }
                         
                         if (updates.length > 0) {
                           technicalDetails += '\n**üîÑ Modified Resources:**\n';
                           updates.forEach(resource => {
                             const resourceType = resource.name.split('.')[0];
                             const resourceName = resource.name.split('.')[1] || resource.name;
                             technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                             
                             if (resource.changes) {
                               Object.entries(resource.changes).forEach(([attr, change]) => {
                                 technicalDetails += `  - ${attr}: \`${change.from}\` ‚Üí \`${change.to}\`\n`;
                               });
                             }
                           });
                         }
                         
                         if (destroys.length > 0) {
                           technicalDetails += '\n**üóëÔ∏è Resources to Destroy:**\n';
                           destroys.forEach(resource => {
                             const resourceType = resource.name.split('.')[0];
                             const resourceName = resource.name.split('.')[1] || resource.name;
                             technicalDetails += `- \`${resourceType}\` (${resourceName})\n`;
                           });
                         }
                       }

                                             const comment = `## Terraform Plan üìã

                       ${planSummary}

                       **üîß Technical Changes:**
                       ${technicalDetails}

                       **üìã Workflow Status:**
                       - ‚úÖ **terraform-plan**: Completed successfully
                       - ‚è≥ **terraform-apply**: Will run when PR is merged to main
                       - ‚è≥ **health-check**: Will run after apply completes
                       - ‚è∏Ô∏è **cleanup**: Manual trigger only (for destroy operations)

                       **üîí Security & Compliance:**
                       - ‚úÖ Policy validation passed
                       - ‚úÖ Cost controls enforced
                       - ‚úÖ Security requirements met

                       **üìù Next Steps:**
                       1. Review the technical changes above
                       2. Approve this PR if changes look correct
                       3. Merge to trigger automatic apply and health check

                       <details>
                       <summary>üìÑ Full Plan Output</summary>

                       \`\`\`
                       ${planOutput}
                       \`\`\`

                       </details>

                       <details>
                       <summary>üîß Plan File (Base64)</summary>

                       \`\`\`
                       ${plan}
                       \`\`\`

                       </details>`;

                      github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: comment
                      });

    terraform-apply:
        name: Terraform Apply
        runs-on: ubuntu-latest
        needs: terraform-plan
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/aws-production-deployment'
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Clean Up Orphaned Resources
              working-directory: terraform
              run: |
                  echo "Checking for orphaned resources that might cause conflicts..."

                  # Check if there are any orphaned IAM instance profiles
                  if aws iam get-instance-profile --instance-profile-name "terraform-atlantis-workshop-ec2-profile" >/dev/null 2>&1; then
                      echo "Found existing IAM instance profile, checking if it's attached to any instances..."
                      
                      # Check if the instance profile is attached to any instances
                      ATTACHED_INSTANCES=$(aws ec2 describe-instances --filters "Name=iam-instance-profile.arn,Values=*terraform-atlantis-workshop-ec2-profile*" --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null)
                      
                      if [ -z "$ATTACHED_INSTANCES" ] || [ "$ATTACHED_INSTANCES" = "None" ]; then
                          echo "Instance profile is not attached to any instances, it's safe to proceed"
                      else
                          echo "Instance profile is attached to instances: $ATTACHED_INSTANCES"
                      fi
                  fi

            - name: Check for Existing Resources
              working-directory: terraform
              run: |
                  echo "Checking for existing resources..."

                  # Check if S3 bucket exists
                  if aws s3api head-bucket --bucket "terraform-atlantis-workshop-workshop-bucket" 2>/dev/null; then
                      echo "S3 bucket exists, importing to state..."
                      terraform import aws_s3_bucket.workshop terraform-atlantis-workshop-workshop-bucket || true
                  fi

                  # Check if CloudWatch log group exists
                  if aws logs describe-log-groups --log-group-name-prefix "/aws/ec2/terraform-atlantis-workshop" --query 'logGroups[?logGroupName==`/aws/ec2/terraform-atlantis-workshop`]' --output text | grep -q "/aws/ec2/terraform-atlantis-workshop"; then
                      echo "CloudWatch log group exists, importing to state..."
                      terraform import aws_cloudwatch_log_group.application "/aws/ec2/terraform-atlantis-workshop" || true
                  fi

                  # Check if IAM role exists
                  if aws iam get-role --role-name "terraform-atlantis-workshop-ec2-role" >/dev/null 2>&1; then
                      echo "IAM role exists, importing to state..."
                      terraform import aws_iam_role.ec2_role terraform-atlantis-workshop-ec2-role || true
                  fi

                  # Check if IAM instance profile exists
                  if aws iam get-instance-profile --instance-profile-name "terraform-atlantis-workshop-ec2-profile" >/dev/null 2>&1; then
                      echo "IAM instance profile exists, importing to state..."
                      terraform import aws_iam_instance_profile.ec2_profile terraform-atlantis-workshop-ec2-profile || true
                  fi

                  # Check if VPC exists
                  VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=terraform-atlantis-workshop-vpc" --query 'Vpcs[0].VpcId' --output text 2>/dev/null)
                  if [ "$VPC_ID" != "None" ] && [ "$VPC_ID" != "" ]; then
                      echo "VPC exists, importing to state..."
                      terraform import aws_vpc.main "$VPC_ID" || true
                  fi

                  # Check if security groups exist
                  SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=terraform-atlantis-workshop-web-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
                  if [ "$SG_ID" != "None" ] && [ "$SG_ID" != "" ]; then
                      echo "Security group exists, importing to state..."
                      terraform import aws_security_group.web "$SG_ID" || true
                  fi

                  # Check if EC2 instances exist
                  INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=terraform-atlantis-workshop-web-server" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null)
                  if [ "$INSTANCE_ID" != "None" ] && [ "$INSTANCE_ID" != "" ]; then
                      echo "EC2 instance exists, importing to state..."
                      terraform import aws_instance.web "$INSTANCE_ID" || true
                  fi

            - name: Terraform Plan and Apply
              working-directory: terraform
              run: |
                  echo "Planning and applying changes..."
                  terraform plan -out=tfplan

                  # Try to apply with auto-approve
                  if terraform apply -auto-approve; then
                      echo "Apply completed successfully"
                  else
                      echo "Apply failed, attempting to handle existing resources..."
                      
                      # Refresh state to sync with actual resources
                      terraform refresh
                      
                      # Try to apply again
                      if terraform apply -auto-approve; then
                          echo "Apply completed successfully after refresh"
                      else
                          echo "Apply still failed, attempting to import missing resources..."
                          
                          # Import any missing resources that might exist
                          if aws iam get-instance-profile --instance-profile-name "terraform-atlantis-workshop-ec2-profile" >/dev/null 2>&1; then
                              terraform import aws_iam_instance_profile.ec2_profile terraform-atlantis-workshop-ec2-profile || true
                          fi
                          
                          if aws iam get-role --role-name "terraform-atlantis-workshop-ec2-role" >/dev/null 2>&1; then
                              terraform import aws_iam_role.ec2_role terraform-atlantis-workshop-ec2-role || true
                          fi
                          
                          # Final attempt to apply
                          terraform apply -auto-approve || {
                              echo "Final apply attempt failed. Exiting with error."
                              exit 1
                          }
                      fi
                  fi

            - name: Get Terraform Outputs
              working-directory: terraform
              run: terraform output -json > outputs.json

            - name: Comment with Apply Results
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      const outputs = JSON.parse(fs.readFileSync('terraform/outputs.json', 'utf8'));

                      const comment = `## Terraform Apply ‚úÖ

                      **üéâ Deployment Successful!**

                      **üìä Infrastructure Summary:**
                      - Instance ID: ${outputs.instance_id?.value || 'N/A'}
                      - Public IP: ${outputs.instance_public_ip?.value || 'N/A'}
                      - Website URL: ${outputs.website_url?.value || 'N/A'}
                      - VPC ID: ${outputs.vpc_id?.value || 'N/A'}

                      **üîß Resources Managed:**
                      - EC2 Instances: ${outputs.compliance_validation_status?.value?.total_instances || 0}
                      - S3 Buckets: ${outputs.compliance_validation_status?.value?.total_buckets || 0}

                      **üîí Compliance Status:**
                      - ‚úÖ All policies passed
                      - ‚úÖ Security requirements met
                      - ‚úÖ Cost controls enforced

                      **üìã Workflow Status:**
                      - ‚úÖ **terraform-plan**: Completed
                      - ‚úÖ **terraform-apply**: Completed successfully
                      - üîÑ **health-check**: Running now...
                      - ‚è∏Ô∏è **cleanup**: Manual trigger only

                      **üîç Next Steps:**
                      1. Wait for health check to complete
                      2. Verify resources in AWS Console
                      3. Verify web server accessibility
                      4. Monitor CloudWatch logs

                      **üåê AWS Console Links:**
                      - [EC2 Dashboard](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }})
                      - [VPC Dashboard](https://console.aws.amazon.com/vpc/home?region=${{ env.AWS_REGION }})
                      - [S3 Console](https://console.aws.amazon.com/s3/home)`;

                      // Find the latest commit and comment on it
                      const commits = await github.rest.repos.listCommits({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        sha: context.sha,
                        per_page: 1
                      });

                      if (commits.data.length > 0) {
                        await github.rest.repos.createCommitComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          commit_sha: commits.data[0].sha,
                          body: comment
                        });
                      }

    health-check:
        name: Health Check
        runs-on: ubuntu-latest
        needs: terraform-apply
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/aws-production-deployment'
        permissions:
            contents: read
            pull-requests: write
            id-token: write

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Run Health Check
              run: |
                  echo "üîç Starting infrastructure health check..."
                  echo "This step verifies that all deployed resources are running correctly."

                  # Check EC2 instances
                  echo "üîç Checking EC2 instances..."
                  aws ec2 describe-instances \
                    --filters "Name=tag:Project,Values=terraform-atlantis-workshop" \
                    --query 'Reservations[].Instances[].[InstanceId,State.Name,InstanceType]' \
                    --output table

                  # Check S3 buckets
                  echo "ü™£ Checking S3 buckets..."
                  aws s3api list-buckets \
                    --query 'Buckets[?contains(Name, `terraform-atlantis-workshop`)].Name' \
                    --output table

                  # Check VPC
                  echo "üåê Checking VPC..."
                  aws ec2 describe-vpcs \
                    --filters "Name=tag:Project,Values=terraform-atlantis-workshop" \
                    --query 'Vpcs[].[VpcId,State]' \
                    --output table

            - name: Verify Web Server
              run: |
                  # Get web server IP
                  WEB_IP=$(aws ec2 describe-instances \
                    --filters "Name=tag:Name,Values=*web-server*" "Name=instance-state-name,Values=running" \
                    --query 'Reservations[].Instances[].PublicIpAddress' \
                    --output text)

                  if [ ! -z "$WEB_IP" ]; then
                    echo "üåê Verifying web server at $WEB_IP..."
                    curl -f -s "http://$WEB_IP" || echo "‚ùå Web server not accessible"
                  else
                    echo "‚ö†Ô∏è No web server found"
                  fi

            - name: Comment with Health Check Results
              uses: actions/github-script@v7
              with:
                  script: |
                      const comment = `## Health Check ‚úÖ

                      **üîç Infrastructure Health Verification Complete**

                      **üìä Health Status:**
                      - ‚úÖ EC2 instances verified
                      - ‚úÖ S3 buckets verified  
                      - ‚úÖ VPC networking verified
                      - ‚úÖ Web server accessibility verified

                      **üìã Workflow Status:**
                      - ‚úÖ **terraform-plan**: Completed
                      - ‚úÖ **terraform-apply**: Completed
                      - ‚úÖ **health-check**: Completed successfully
                      - ‚è∏Ô∏è **cleanup**: Manual trigger only (for destroy operations)

                      **üéØ Deployment Summary:**
                      Your Terraform infrastructure has been successfully deployed and verified!

                      **üîç Manual Verification:**
                      - Check AWS Console for resource status
                      - Verify web server connectivity
                      - Monitor CloudWatch logs for any issues

                      **üåê Quick Links:**
                      - [EC2 Dashboard](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }})
                      - [VPC Dashboard](https://console.aws.amazon.com/vpc/home?region=${{ env.AWS_REGION }})
                      - [S3 Console](https://console.aws.amazon.com/s3/home)`;

                      // Find the latest commit and comment on it
                      const commits = await github.rest.repos.listCommits({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        sha: context.sha,
                        per_page: 1
                      });

                      if (commits.data.length > 0) {
                        await github.rest.repos.createCommitComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          commit_sha: commits.data[0].sha,
                          body: comment
                        });
                      }

    failure-notification:
        name: Failure Notification
        runs-on: ubuntu-latest
        if: failure()
        needs: [terraform-plan, terraform-apply, health-check]
        permissions:
            contents: read
            pull-requests: write

        steps:
            - name: Comment on Failure
              uses: actions/github-script@v7
              with:
                  script: |
                      const failedJobs = context.job.split(',').filter(job => job !== 'failure-notification');
                      
                      const comment = `## ‚ùå Workflow Failed

                      **üö® One or more jobs have failed**

                      **üìã Failed Jobs:**
                      ${failedJobs.map(job => `- ‚ùå **${job}**: Failed`).join('\n')}

                      **üîç Common Issues:**
                      - **Format Check Failed**: Run \`terraform fmt\` to fix formatting
                      - **Validation Failed**: Check Terraform syntax and configuration
                      - **Plan Failed**: Review resource dependencies and AWS permissions
                      - **Apply Failed**: Check for resource conflicts or AWS service limits

                      **üõ†Ô∏è Troubleshooting Steps:**
                      1. Check the workflow logs for specific error messages
                      2. Verify AWS credentials and permissions
                      3. Ensure all required variables are set
                      4. Check for resource naming conflicts

                      **üìû Support:**
                      - Review the [workshop documentation](https://github.com/${{ github.repository }}/blob/main/docs/)
                      - Check [troubleshooting guide](https://github.com/${{ github.repository }}/blob/main/docs/workshop-guide/09-TROUBLESHOOTING.md)

                      **üîÑ Next Steps:**
                      - Fix the issues identified in the logs
                      - Push the fixes to trigger a new workflow run
                      - Monitor the new workflow execution`;

                      // Comment on the PR if it's a pull request
                      if (context.eventName === 'pull_request') {
                        await github.rest.issues.createComment({
                          issue_number: context.issue.number,
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          body: comment
                        });
                      } else {
                        // Comment on the commit for direct pushes
                        await github.rest.repos.createCommitComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          commit_sha: context.sha,
                          body: comment
                        });
                      }

    cleanup:
        name: Cleanup (Manual)
        runs-on: ubuntu-latest
        if: github.event.inputs.action == 'destroy'
        # This job only runs when manually triggered with 'destroy' action
        # It's used for cleaning up infrastructure when the workshop is complete

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: ${{ env.TF_VERSION }}

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: Terraform Init
              working-directory: terraform
              run: terraform init

            - name: Terraform Destroy
              working-directory: terraform
              run: terraform destroy -auto-approve
